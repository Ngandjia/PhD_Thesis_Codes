# We import the SageMath library into Python
from sage.all import diff, QQ, var, PolynomialRing

# We define variables
A = PolynomialRing(QQ, ['a_1', 'a_2', 'a_3', 'a_4', 'b_1', 'b_2', 'b_3', 'b_4'], order='degrevlex')
a_1, a_2, a_3, a_4, b_1, b_2, b_3, b_4 = A.gens()

class Operator:

    def X(f):
        """
        Apply the X differential operator to the function f.
        """
        f = A(f)
        return (a_1*diff(f, a_2) + 2*a_2*diff(f, a_3) + 
                3*a_3*diff(f, a_4) + b_1*diff(f, b_2) + 
                2*b_2*diff(f, b_3) + 3*b_3*diff(f, b_4))

    def Y(f):
        """
        Apply the Y differential operator to the function f.
        """
        f = A(f)
        return (3*a_2*diff(f, a_1) + 2*a_3*diff(f, a_2) + 
                a_4*diff(f, a_3) + 3*b_2*diff(f, b_1) + 
                2*b_3*diff(f, b_2) + b_4*diff(f, b_3))

    def Z(f):
        """
        Apply the Z differential operator (which is defined as [X, Y]) to the function f.
        """
        return (Operator.X(Operator.Y(f)) - Operator.Y(Operator.X(f)))

    def Xtimes(f, n):
        """
        Apply the X differential operator n times to the function f.
        """
        for i in range(n):
            f = Operator.X(f)
        return (f)

    def Ytimes(f, n):
        """
        Apply the Y differential operator n times to the function f.
        """
        for _ in range(n):
            f = Operator.Y(f)
        return (f)
    
    def stability(I, G) :
        """
        Check the stability of the ideal I (generated by G) under the action of sl_2(C).
        """
        for function in [Operator.X, Operator.Y] :
            count = 0
            for f in G :
                veracity = True
                while f != 0 :
                    f = function(f)
                    veracity = veracity and (f in I)
                if veracity == True :
                    count += 1
            print(f"Action of {function} : {count == len(G)}")


class ProdActOperator :

    def X_1(f):
        """
        Apply the first component differential operator X to the function f.
        """
        f = A(f)
        return (a_1*diff(f, a_2) + 2*a_2*diff(f, a_3) + 
                3*a_3*diff(f, a_4) + b_1*diff(f, b_2) + 
                2*b_2*diff(f, b_3) + 3*b_3*diff(f, b_4))

    def Y_1(f):
        """
        Apply the first component differential operator Y to the function f.
        """
        f = A(f)
        return (3*a_2*diff(f, a_1) + 2*a_3*diff(f, a_2) + 
                a_4*diff(f, a_3) + 3*b_2*diff(f, b_1) + 
                2*b_3*diff(f, b_2) + b_4*diff(f, b_3))

    def Z_1(f): 
        """
        Apply the first component differential operator Z (which is defined as [X, Y]) to the function f.
        """
        return (ProdActOperator.X_1(ProdActOperator.Y_1(f)) - ProdActOperator.Y_1(ProdActOperator.X_1(f)))
    
    def X_2(f):
        """
        Apply the second component differential operator X to the function f.
        """
        f = A(f)
        return (a_1*diff(f, b_1) + a_2*diff(f, b_2) + 
                a_3*diff(f, b_3) + a_4*diff(f, b_4))

    def Y_2(f):
        """
        Apply the second component differential operator Y to the function f.
        """
        f = A(f)
        return (b_1*diff(f, a_1) + b_2*diff(f, a_2) + 
                b_3*diff(f, a_3) + b_4*diff(f, a_4))

    def Z_2(f):
        """
        Apply the second component differential operator Z to the function f.
        """
        return (ProdActOperator.X_2(ProdActOperator.Y_2(f)) - ProdActOperator.Y_2(ProdActOperator.X_2(f)))

    def X_1times(f, n):
        """
        Apply X_1 n times to the function f.
        """
        for i in range(n):
            f = ProdActOperator.X_1(f)
        return (f)
    
    def Y_1times(f, n):
        """
        Apply Y_1 n times to the function f.
        """
        for i in range(n):
            f = ProdActOperator.Y_1(f)
        return (f)

    def X_2times(f, n):
        """
        Apply X_2 n times to the function f.
        """
        for i in range(n):
            f = ProdActOperator.X_2(f)
        return (f)
    
    def Y_2times(f, n):
        """
        Apply Y_2 n times to the function f.
        """
        for i in range(n):
            f = ProdActOperator.Y_2(f)
        return (f)
    
    def stability(I, G) :
        """
        Check the stability of the ideal I (generated by G) under the action of sl_2(C) x sl_2(C).
        """
        for function in [ProdActOperator.X_1, ProdActOperator.X_2, ProdActOperator.Y_1, ProdActOperator.Y_2] :
            count = 0
            for f in G :
                veracity = True
                while f != 0 :
                    f = function(f)
                    veracity = veracity and (f in I)
                if veracity == True :
                    count += 1
            print(f"Action of {function} : {count == len(G)}")